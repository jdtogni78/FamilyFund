<?php namespace Tests\APIs;

use App\Models\Asset;
use App\Models\AssetPrice;
use App\Models\PriceUpdate;
use App\Models\SymbolPrice;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Nette\Utils\DateTime;
use Tests\TestCase;
use Tests\ApiTestTrait;
use const null;

class PriceUpdateApiExtTest extends TestCase
{
    use ApiTestTrait, WithoutMiddleware, DatabaseTransactions;
    private $post;
    private $symbols;
    private $priceUpdate;
    protected $date;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->date = new DateTime("2022-01-01");
    }

    public function testMissingFields()
    {
        $this->_testUnset('timestamp', 422);
        $this->_testUnset('source', 422);
        $this->_testUnsetSymbol('name', 422);
        $this->_testUnsetSymbol('price', 422);
    }

    public function testMissingOptionalFields()
    {
//        $this->_testUnsetSymbol('type', 200);
    }

    public function testCashErrors()
    {
        $assetsArr = $this->createSamplePriceUpdateReq();
        $assetsArr['symbols'][] = $this->makeSymbol('CASH');
        $this->postError($assetsArr);

        $assetsArr = $this->createSamplePriceUpdateReq();
        $assetsArr['symbols'][] = $this->makeSymbol(null, 'CSH');
        $this->postError($assetsArr);
    }

    public function testBasic()
    {
        $this->post = $post = $this->createSamplePriceUpdateReq();
        $this->postAPI($post);
        $this->validateSampleRequest('validateUniqueHistorical');
    }

    public function testHistory()
    {
        $this->createSamplePriceUpdateReq();
        $this->postAPI($this->post);

        $ts1 = $this->timestamp();
        $this->nextDay(4);
        $this->postAPI($this->post);
        $this->validateSampleRequest('validateUniqueHistorical', $ts1);

        $this->nextDay(1);
        $ts2 = $this->timestamp();
        $p2 = $this->post['symbols'][1];
        unset($this->post['symbols'][1]);
        $price1 = $this->post['symbols'][0]['price'];
        $price2 = $this->post['symbols'][0]['price'] = 11.11;
        $this->postAPI($this->post);

        $this->validateSampleRequest('validate2Historical', $ts1, $price1);

        $p1 = $this->post['symbols'][0];
        print_r(json_encode($this->post)."\n");
        $this->post['symbols'] = [$p2];
        print_r(json_encode($this->post)."\n");
        $this->validateSampleRequest('validateUniqueHistorical', $ts1);

        $this->prevDay();
        $this->prevDay();
        $this->prevDay();
        print_r(json_encode($this->post)."\n");
        unset($this->post['symbols'][0]);
        $this->post['symbols'] = [$p1];
        print_r(json_encode($this->post)."\n");
        $this->post['symbols'][0]['price'] = 55.55;
        print_r(json_encode($this->post)."\n");
        $this->postAPI($this->post);

        $this->validateSampleRequest('validate3Historical', $ts1, $price1, $ts2, $price2);

    }

    public function validateNoChangeCash(): void
    {
        $aps = Asset::where('name', 'CASH')->get()->first()->assetPrices()->get();
        $this->validateUniqueHistorical($aps, 'price', 'CASH', 1.0,
            '2000-01-01', 1.0);
    }

    public function _testUnsetSymbol($key, $error_code)
    {
        $assetsArr = $this->createSamplePriceUpdateReq();
        foreach ($assetsArr['symbols'] as &$symbol) {
            unset($symbol[$key]);
        }

        $this->postError($assetsArr, $error_code);
    }

    public function _testUnset($key, $error_code)
    {
        $assetsArr = $this->createSamplePriceUpdateReq();
        unset($assetsArr[$key]);

        $this->postError($assetsArr, $error_code);
    }


    protected function createSamplePriceUpdateReq(): array
    {
        $this->symbols = SymbolPrice::factory()->count(2)->make();
        $this->priceUpdate = PriceUpdate::factory()->make([
            'timestamp' => $this->timestamp()
        ]);

        $assetsArr = $this->priceUpdate->toArray();
        $assetsArr['symbols'] = $this->symbols->toArray();
        $this->post = $assetsArr;
        return $assetsArr;
    }

    protected function postError(array $assetsArr, $error_code = 422): void
    {
        print_r(json_encode($assetsArr)."\n");
        $this->response = $this->json(
            'POST',
            '/api/asset_prices_bulk_update', $assetsArr
        );

        $this->assertApiError($error_code);
    }

    protected function makeSymbol($name=null, $type=null): array
    {
        $values = [];
        if ($name) $values['name'] = $name;
        if ($type) $values['type'] = $type;
        return SymbolPrice::factory()->make($values)->toArray();
    }

    private function assertAssetSymbol($asset, mixed $symbol)
    {
        $this->assertEquals($asset->source, $symbol['source']);
        $this->assertEquals($asset->name, $symbol['name']);
        $this->assertEquals($asset->type, $symbol['type']);
        if (array_key_exists('created_at', $symbol))  $this->assertDate($asset->created_at,  $symbol['created_at']);
        if (array_key_exists('updated_at', $symbol))  $this->assertDate($asset->updated_at,  $symbol['updated_at']);
    }

    protected function postAPI(array $post): void
    {
        print_r("*** POST: " . json_encode($post)."\n");
        $this->response = $this->json(
            'POST',
            '/api/asset_prices_bulk_update', $post
        );

        $this->assertEmptyData();
        $this->assertApiSuccess();
    }

    protected function validateSampleRequest($func, $ts1=null, $value1=null, $ts2=null, $value2=null): void
    {
        if ($ts1 == null) $ts1 = $this->post['timestamp'];

        foreach ($this->post['symbols'] as $symbol) {
            $symbol['source'] = $this->post['source'];

            $res = Asset::where('source', $this->post['source'])
                ->where('name', $symbol['name'])
                ->get();

            $this->assertCount(1, $res->toArray());
            $asset = $res->first();
            print_r(json_encode($asset) . "\n");

            $symbol['updated_at'] = $symbol['created_at'] = date('Y-m-d');
            $this->assertAssetSymbol($asset, $symbol);

            $aps = $asset->assetPrices()->get();
            $this->$func($aps, 'price', $symbol['name'], $symbol['price'], $ts1, $value1, $ts2, $value2);
        }
        $this->validateNoChangeCash();
    }

    protected function  validate3Historical($collection, $field, $name, $expectedValue, $ts1, $value1, $ts2, $value2)
    {
        print_r(json_encode([$name, $ts1, $expectedValue, $ts2, $value2])."\n");
        $this->assertEquals(3, count($collection));
        foreach ($collection as $obj) {
            print_r(json_encode($obj)."\n");
            if ($this->compareTimestamp($obj->start_dt, $this->post['timestamp'])) { // middle record
                $this->assertTrue($this->compareTimestamp($obj->end_dt, $ts2));
                $this->assertEquals($expectedValue, $obj[$field]);
            } else if ($this->compareTimestamp($obj->start_dt, $ts1)) {
                $this->assertTrue($this->compareTimestamp($obj->end_dt, $this->post['timestamp']));
                $this->assertEquals($value1, $obj->$field);
            } else {
                $this->assertTrue($this->compareTimestamp($obj->start_dt, $ts2));
                $this->assertTrue($this->isInfinity($obj->end_dt));
                $this->assertEquals($value2, $obj->$field);
            }
        }
    }
    protected function validate2Historical($collection, $field, $name, $expectedValue, $oldTs, $oldExpectedValue, $ts2=null, $value2=null)
    {
        print_r(json_encode([$name, $oldTs, $expectedValue])."\n");
        $this->assertEquals(2, count($collection));
        foreach ($collection as $obj) {
            print_r(json_encode($obj)."\n");
            if ($this->compareTimestamp($obj->start_dt, $this->post['timestamp'])) {
                $this->assertEquals($expectedValue, $obj->$field);
                $this->assertTrue($this->isInfinity($obj->end_dt));
            } else {
                $this->assertEquals($oldExpectedValue, $obj->$field);
                $this->assertTrue($this->compareTimestamp($obj->start_dt, $oldTs));
                $this->assertTrue($this->compareTimestamp($obj->end_dt,   $this->post['timestamp']));
            }
        }
    }

    public function validateUniqueHistorical($collection, $field, $name, $expectedValue, $timestamp, $oldValue=null, $ts2=null, $value2=null): void
    {
        $count = count($collection);
        $this->assertEquals(1, $count);

        $count = 0;
        foreach ($collection as $obj) {
            print_r(json_encode($obj)."\n");
            if ($this->compareTimestamp($obj->start_dt, $timestamp)) {
                $this->assertEquals($obj->{$field}, $expectedValue);
                $this->assertTrue($this->isInfinity($obj->end_dt));
                $count++;
            }
        }
        $this->assertEquals(1, $count);
    }

    private function assertPriceSymbol(mixed $ap, $asset, mixed $symbol)
    {
        $this->assertEquals($ap->asset_id, $asset->id);
        if (array_key_exists('price',    $symbol))  $this->assertEquals($ap->price,     $symbol['price']);
        if (array_key_exists('start_dt', $symbol))  $this->assertDate($ap->start_dt,  $symbol['start_dt']);
        if (array_key_exists('end_dt',   $symbol))  $this->assertDate($ap->end_dt,    $symbol['end_dt']);
    }

    protected function compareTimestamp(mixed $timestamp, mixed $timestamp1)
    {
        return substr($timestamp, 0, 10) == substr($timestamp1, 0, 10);
    }

    protected function isInfinity(mixed $end_dt)
    {
        return $this->compareTimestamp($end_dt, "9999-12-31");
    }

    protected function assertDate(mixed $expected, mixed $actual)
    {
        $this->assertEquals(substr($expected, 0, 10), substr($actual, 0, 10));
    }

    protected function assertEmptyData()
    {
        print_r($this->response->content()."\n");
        $res = json_decode($this->response->content());
        $this->assertEmpty($res->data);
    }

    protected function updateTimestamp()
    {
        $this->post["timestamp"] = $this->timestamp();
    }

    public function timestamp(): string
    {
        return $this->date->format('Y-m-d') . "T00:00:00";
    }

    public function nextDay(int $days)
    {
        $this->date->modify('+'.$days.' day');
        $this->updateTimestamp();
    }

    public function prevDay()
    {
        $this->date->modify('-1 day');
        $this->updateTimestamp();
    }
}
