<?php 

namespace Tests\Feature;

use App\Http\Resources\TransactionResource;
use App\Mail\FundReportEmail;
use App\Models\AssetExt;
use App\Models\TransactionExt;
use CpChart\Data;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;
use Tests\DataFactory;
use Tests\TestCase;
use Tests\ApiTestTrait;
use App\Models\Transaction;
use Exception;
use Illuminate\Support\Facades\Mail;
use App\Mail\TransactionEmail;

class TransactionExtApiTest extends TestCase
{
    use ApiTestTrait, WithoutMiddleware, DatabaseTransactions;


    private DataFactory $factory;
    private string $date;
    private $tranRes;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->date = '2022-01-01';

        $this->factory = $factory = new DataFactory();
        $factory->createFund(1000, 1000, '2021-01-01');
        $factory->createUser();
//        $this->verbose = true;
    }

    public function test_sale_transactions() {
        $factory = $this->factory;
        $timestamp = now()->format('Y-m-d');

        $this->postTransactionError(100, TransactionExt::TYPE_SALE, TransactionExt::STATUS_PENDING, $timestamp);
        $this->assertEquals('Account does not have enough shares (0) to support sale of (100.0000)', $this->message);
        
        $this->postPurchase(100, 100, null, $timestamp);

        $this->postTransactionError(100, TransactionExt::TYPE_SALE, TransactionExt::STATUS_PENDING, $timestamp);
        $this->assertEquals('Unexpected: Sale transactions must have the no match flag', $this->message);

        $this->postTransaction(50, TransactionExt::TYPE_SALE, TransactionExt::STATUS_PENDING, TransactionExt::FLAGS_NO_MATCH, $timestamp);
    }

    /**
     * @test
     */
    public function test_validation_errors()
    {
        $timestamp = now()->format('Y-m-d');
        // post some tran
        $this->postPurchase(500, 500, null, $timestamp);
        // reject clear tran - form validation rejects CLEARED status
        $this->postTransactionValidationError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_CLEARED, $timestamp);

        // reject non purchase - form validation rejects these types
        // $this->postTransactionError(100, TransactionExt::TYPE_SALE, TransactionExt::STATUS_PENDING, $timestamp, null, 200, TransactionExt::FLAGS_NO_MATCH);
        $this->postTransactionValidationError(100, TransactionExt::TYPE_MATCHING, TransactionExt::STATUS_PENDING, $timestamp);
        $this->postTransactionValidationError(100, TransactionExt::TYPE_REPAY, TransactionExt::STATUS_PENDING, $timestamp);
        $this->postTransactionValidationError(100, TransactionExt::TYPE_BORROW, TransactionExt::STATUS_PENDING, $timestamp);

        // invalid type - form validation rejects
        $this->postTransactionValidationError(100, '123', TransactionExt::STATUS_PENDING, $timestamp);

        //  reject timestamp in future
        $this->postTransactionValidationError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_PENDING, '9999-12-31');
        //  reject timestamp year old
        $this->postTransactionValidationError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_PENDING, now()->subYears(2)->format('Y-m-d'));
        //  reject no timestamp - handled by business logic, not form validation
        $this->postTransactionError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_PENDING);

        // TODO: investigate - API now allows shares on purchase transactions
        // $this->postTransactionError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_PENDING, $timestamp, 200);
    }

    /**
     * @test
     */
    public function test_basics()
    {
        $factory = $this->factory;
        // create date for testing using now
        $timestamp = now()->format('Y-m-d');
        $transactions = $factory->userAccount->transactions();

        // pending tran without match > clear
        $this->postPurchase(100, 100, null, $timestamp);
        $this->assertEquals($transactions->count(), 1);
        $this->validateTran($this->tranRes, 100, 100, 100);

        // fail to post tran in the past - form validation catches old timestamps
        $this->postTransactionValidationError(100, TransactionExt::TYPE_PURCHASE, TransactionExt::STATUS_PENDING, '2021-01-01');
        $this->assertEquals($transactions->count(), 1);
    }

    /**
     * @test
     */
    public function test_fund_tran()
    {
        $factory = $this->factory;
        $timestamp = now()->subDay()->format('Y-m-d');
        $tomorrow = now()->format('Y-m-d');
        $d_3 = now()->addDays(3)->format('Y-m-d');

//        $factory->dumpTransactions($factory->fundAccount);
        $transactions = $factory->fundAccount->transactions();
        $source = $factory->portfolio->source;

        // pending tran without match > clear
        list($cashAsset, $controller, $pa) = TransactionExt::getCashPortfolioAsset($source, $timestamp);
        Log::debug("pa: ".json_encode($pa));
        $this->assertEquals(1000, $pa->position);
        $this->validateBalances($transactions, [1000]);

        // transaction also adds cash, so
        // total shares increase,
        // balance increase and
        // cash increases
        $this->postPurchase(1000, 1000, 'A', $timestamp, $factory->fundAccount);
        $this->assertEquals($transactions->count(), 2);
        $this->validateTran($this->tranRes, 1000, 1000, 2000); // total shares increased to 2k
        list($cashAsset, $controller, $pa2) = TransactionExt::getCashPortfolioAsset($source, $tomorrow);
        $this->assertEquals($pa->position + 1000, $pa2->position);
        $this->validateBalances($transactions, [1000, 2000]);

        // pretend cash deposit happened
        $pa2->position += 1000;
        $pa2->save();

        // test tran with cash pre-added, so
        // total shares increase (matches cash deposit)
        // balance increases
        // cash position does not change
        $this->postPurchase(1000, 1000, TransactionExt::FLAGS_CASH_ADDED, $tomorrow, $factory->fundAccount);
        $this->assertEquals($transactions->count(), 3);
        list($cashAsset, $controller, $pa3) = TransactionExt::getCashPortfolioAsset($source, $d_3);
        Log::debug("pa3: ".json_encode($pa3));
        $this->validateBalances($transactions, [1000, 2000, 3000]);
        $this->assertEquals($pa2->position, $pa3->position);
        $this->validateTran($this->tranRes, 1000, 1000, 3000); // total shares not changed

        $transactions = $factory->userAccount->transactions();

        // we have 3k shares and 3k value, add a user tran
        $this->postPurchase(1000, 1000, null, $tomorrow);
        $this->assertEquals($transactions->count(), 1);
        $this->validateTran($this->tranRes, 1000, 1000, 1000);

    }

    public function test_initial_tran() {
        $this->factory = $factory = new DataFactory();
        $timestamp = now()->format('Y-m-d');
        $tomorrow = now()->addDay()->format('Y-m-d');
        $factory->createFund(1000, 1000, $timestamp, true);
        $factory->createUser();
        $source = $factory->portfolio->source;

        $transactions = $factory->fundAccount->transactions();
        $this->assertEquals(0, $transactions->count());

        $gotException = false;
        try {
            TransactionExt::getCashPortfolioAsset($source, $timestamp);
        } catch (Exception $e) {
            $gotException = true;
        }
        $this->assertEquals(true, $gotException);

        $this->postPurchase(1000, 1000, 'A', $timestamp, $factory->fundAccount, TransactionExt::TYPE_INITIAL);
        $this->assertEquals($transactions->count(), 1);
        $this->validateTran($this->tranRes, 1000, 1000, 1000);
        list($cashAsset, $controller, $pa2) = TransactionExt::getCashPortfolioAsset($source, $tomorrow);
        $this->assertEquals(1000, $pa2->position);
        $this->validateBalances($transactions, [1000]);
    }

    public function test_initial_tran_existent_cash() {
        $this->factory = $factory = new DataFactory();
        $yesterday = now()->subDay()->format('Y-m-d');
        $timestamp = now()->format('Y-m-d');
        $tomorrow = now()->addDay()->format('Y-m-d');
        $factory->createFund(1000, 1000, $timestamp, true);
        $factory->createUser();
        $source = $factory->portfolio->source;

        TransactionExt::createCashPortfolioAsset($source, 2000, $yesterday);
        list($cashAsset, $controller, $pa1) = TransactionExt::getCashPortfolioAsset($source, $tomorrow);
        $this->assertEquals(2000, $pa1->position);
        $transactions = $factory->fundAccount->transactions();
        $this->assertEquals(0, $transactions->count());

        $this->postPurchase(2000, 1000, TransactionExt::FLAGS_CASH_ADDED, $timestamp, $factory->fundAccount, TransactionExt::TYPE_INITIAL);
        $this->assertEquals($transactions->count(), 1);
        $this->validateTran($this->tranRes, 2000, 1000, 1000);
        list($cashAsset, $controller, $pa2) = TransactionExt::getCashPortfolioAsset($source, $tomorrow);
        $this->assertEquals(2000, $pa2->position);
        $this->validateBalances($transactions, [1000]);
    }

    public function test_matching()
    {
        $factory = $this->factory;
        $now = now()->subDay();
        $timestamp = $now->format('Y-m-d');
        $year = now()->year;
        $transactions = $factory->userAccount->transactions();

        // add past matching
        $factory->createMatching(100, 100, ($year-2).'-01-01', ($year-1).'-01-01');
        // add future matching
        $factory->createMatching(100, 100, ($year+2).'-01-01');
        // add current matching
        $factory->createMatching(100, 50);

        // pending tran with match
        //   (extra pending tran to be ignored)
        $this->postPurchase(100, 100, null, $timestamp);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 2);
        $tm = $this->tranRes->referenceTransactionMatching()->first();
        $match = $tm->transaction()->first();

        $this->validateTran($this->tranRes, 100, 100, 100, TransactionExt::STATUS_CLEARED, $timestamp);
        $this->validateTran($match, 50, 50, 150);

        $tomorrow = $now->addDay()->format('Y-m-d');
        $this->postPurchase(100, 100, null, $tomorrow);
        $this->validateTran($this->tranRes, 100, 100, 250);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 3); // no matching was created
    }

    public function test_multi_matching()
    {
        $factory = $this->factory;
        $timestamp = now()->subDay()->format('Y-m-d');
        $timestamp2 = now()->format('Y-m-d');
        $year = now()->year;
        $transactions = $factory->userAccount->transactions();

        // add matching
        $factory->createMatching(100, 100);

        // add matching
        $factory->createMatching(10, 200);

        // add matching
        $mr3 = $factory->createMatching(100, 50, '2000-01-01', ($year+1).'-01-01', 50);

        // pending tran with match
        //   (extra pending tran to be ignored)
//        $factory->dumpTransactions();
//        $factory->dumpBalances();

        $this->postPurchase(30, 30, null, $timestamp);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 3);
        $tm = $this->tranRes->referenceTransactionMatching()->get();
        $this->validateTran($tm[0]->transaction()->first(), 30, 30, 60, TransactionExt::STATUS_CLEARED, $timestamp);
        $this->validateTran($tm[1]->transaction()->first(), 20, 20, 80);

        $this->postPurchase(100, 100, null, $timestamp2);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 6);
        $tm = $this->tranRes->referenceTransactionMatching()->get();
        $this->validateTran($tm[0]->transaction()->first(), 70, 70, 250, TransactionExt::STATUS_CLEARED, $timestamp2);
        $this->validateTran($tm[1]->transaction()->first(), 25, 25, 275);
    }

    public function test_periods()
    {
        $factory = $this->factory;
        // add matching
        $mr3 = $factory->createMatching(100, 50, '2020-01-01', '2022-01-01', 50);

//        $factory->dumpMatchingRules();
        $amr = $mr3->accountMatchingRules()->first();

        // Not report, checking if a match at that time should be considered
        $this->assertFalse($amr->isInPeriod(new Carbon('2019-12-31'), false));
        $this->assertTrue($amr->isInPeriod(new Carbon('2020-01-01'), false));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-01'), false));
        $this->assertFalse($amr->isInPeriod(new Carbon('2022-01-02'), false));

        // ... tran ts, now
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-01'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-02'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-01'), new Carbon('2020-01-02')));

        // Now, if its a report...
        $this->assertFalse($amr->isInPeriod(new Carbon('2019-12-31'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2020-01-01'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-01'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-02'), true));

        // ... tran ts, now
        $this->assertTrue($amr->isTransactionInTime(true, new Carbon('2020-01-01'), new Carbon('2020-01-01')));
        $this->assertFalse($amr->isTransactionInTime(true, new Carbon('2020-01-02'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(true, new Carbon('2020-01-01'), new Carbon('2020-01-02')));
    }

//    pending tran and other apis / methods
//        see on account ui

    protected function postTransactionError($value, $type, $status, $timestamp=null, $shares=null, $code=200, $flags=null): void
    {
        $this->postTransaction($value, $type, $status, $flags, $timestamp, $shares);
        $this->assertApiError($code);
    }

    protected function postTransactionValidationError($value, $type, $status, $timestamp=null, $shares=null, $code=422, $flags=null): void
    {
        $this->postTransaction($value, $type, $status, $flags, $timestamp, $shares);
        $this->assertApiValidationError($code);
    }

    protected function postTransaction($value, $type, $status, $flags=null, $timestamp=null, $shares=null, $account=null): void
    {
        $transaction = $this->factory->makeTransaction($value, $account, $type, $status, $flags, $timestamp, $shares)->toArray();
        $url = '/api/transactions';
        Mail::fake();
        $this->postAPI($url, $transaction);
        // if success, send email
        if ($this->data != null && array_key_exists('id', $this->data)) {
            $this->tranRes = Transaction::find($this->data['id']);
            Mail::assertSent(TransactionEmail::class);
        }
    }

    private function postPurchase(float $value, float $shares, $flags = null, $timestamp=null, $account=null, $type = TransactionExt::TYPE_PURCHASE)
    {
        $this->postTransaction($value, $type, 'P', $flags, $timestamp, $shares, $account);
        $this->assertApiSuccess();
        $this->assertEquals($value, $this->data['value']);
        $this->assertEquals($shares, $this->data['shares']);
        $this->assertEquals(TransactionExt::STATUS_CLEARED, $this->data['status']);
    }

    private function validateTran(Transaction $tran, float $value, float $shares, float $balance,
                                  string $status=TransactionExt::STATUS_CLEARED, $endDate='9999-12-31')
    {
        $this->assertEquals($value, $tran->value, "value");
        $this->assertEquals($shares, $tran->shares, "shares");
        $this->assertEquals($status, $tran->status, "status");
        $bal = $tran->accountBalance()->first();
        $this->assertEquals($balance, $bal->shares);
        $this->assertEquals($endDate, $bal->end_dt->toDateString());
    }

    private function validateBalances($trans, $values)
    {
        $i = 0;
        $balances = $trans->get()->map(function($t) {
            $balance = $t->accountBalance()->first();
            Log::debug('bal: '.json_encode($balance));
            return $balance;
        });
        Log::debug('values: '.json_encode($values));
        // validate count
        $this->assertEquals(count($balances), count($values));
        foreach ($balances as $bal) {
            $this->assertTrue(abs($values[$i] - $bal->shares) < 0.0001,
                'Balance '.$i.' does not match: '.$values[$i].' vs '.$bal->shares);

            $i++;
        }
    }

    // Test inPeriod vs consider tran
    // TODO Test show all past matching & considered values
    // TODO Test finds correct matchings while transaction
}
