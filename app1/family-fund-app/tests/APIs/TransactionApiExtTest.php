<?php namespace Tests\APIs;

use App\Http\Resources\TransactionResource;
use CpChart\Data;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Illuminate\Support\Carbon;
use Symfony\Component\HttpFoundation\Response;
use Tests\DataFactory;
use Tests\TestCase;
use Tests\ApiTestTrait;
use App\Models\Transaction;

class TransactionApiExtTest extends TestCase
{
    use ApiTestTrait, WithoutMiddleware, DatabaseTransactions;


    private DataFactory $factory;
    private string $date;
    private $tranRes;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->date = '2022-01-01';

        $this->factory = $factory = new DataFactory();
        $factory->createFund(1000, 1000, '2021-01-01');
        $factory->createUser();
//        $this->verbose = true;
    }

    /**
     * @test
     */
    public function test_validation_errors()
    {
        // reject clear tran
        $this->postTransactionError(100, 'PUR', 'C');

        // reject non purchase
        $this->postTransactionError(100, 'SAL', 'P');
        $this->postTransactionError(100, 'MAT', 'P');
        $this->postTransactionError(100, 'REP', 'P');
        $this->postTransactionError(100, 'BOR', 'P');

        // invalid type
        $this->postTransactionError(100, '123', 'P');

        //  reject timestamp in future
        $this->postTransactionError(100, 'PUR', 'P', '9999-12-31');
        //  reject timestamp year old
        $this->postTransactionError(100, 'PUR', 'P', '2020-01-01');
        //  reject no timestamp
        $this->postTransactionError(100, 'PUR', 'P');

        // reject has shares
        $this->postTransactionError(100, 'PUR', 'P', '2022-01-01', 200);
    }

    /**
     * @test
     */
    public function test_basics()
    {
        $factory = $this->factory;
        $timestamp = '2022-01-01';
        $transactions = $factory->userAccount->transactions();

        // pending tran without match > clear
        $this->postPurchase(100, $timestamp, 100);
        $this->assertEquals($transactions->count(), 1);
        $this->validateTran($this->tranRes, 100, 100, 100);

        // fail to post tran in the past
        // TODO better error code
        $this->postTransactionError(100, 'PUR', 'P', '2021-12-01');
        $this->assertEquals($transactions->count(), 1);
    }

    /**
     * @test
     */
    public function test_fund_tran()
    {
        $factory = $this->factory;
        $timestamp = '2022-01-01';
//        $factory->dumpTransactions($factory->fundAccount);
        $transactions = $factory->fundAccount->transactions();

        // pending tran without match > clear
        $this->postPurchase(1000, $timestamp, 1000, $factory->fundAccount);
//        $factory->dumpTransactions($factory->fundAccount);
        $this->assertEquals($transactions->count(), 2);
        $this->validateTran($this->tranRes, 1000, 1000, 2000);

    }

    public function test_matching()
    {
        $factory = $this->factory;
        $timestamp = '2022-01-01';
        $transactions = $factory->userAccount->transactions();

        // add past matching
        $factory->createMatching(100, 100, '2000-01-01', '2001-01-01');
        // add future matching
        $factory->createMatching(100, 100, '2025-01-01');
        // add current matching
        $factory->createMatching(100, 50);

        // pending tran with match
        //   (extra pending tran to be ignored)
        $this->postPurchase(100, $timestamp, 100);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 2);
        $tm = $this->tranRes->referenceTransactionMatching()->first();
        $match = $tm->transaction()->first();

        $this->validateTran($this->tranRes, 100, 100, 100, 'C', $timestamp);
        $this->validateTran($match, 50, 50, 150);

        $this->postPurchase(100, '2022-01-02', 100);
        $this->validateTran($this->tranRes, 100, 100, 250);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 3); // no matching was created
    }

    public function test_multi_matching()
    {
        $factory = $this->factory;
        $timestamp = '2021-12-21';
        $timestamp2 = '2021-12-22';
        $transactions = $factory->userAccount->transactions();

        // add matching
        $factory->createMatching(100, 100);

        // add matching
        $factory->createMatching(10, 200);

        // add matching
        $mr3 = $factory->createMatching(100, 50, '2000-01-01', '2022-01-01', 50);

        // pending tran with match
        //   (extra pending tran to be ignored)
        $this->postPurchase(30, $timestamp, 30);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 3);
        $tm = $this->tranRes->referenceTransactionMatching()->get();
        $this->validateTran($tm[0]->transaction()->first(), 30, 30, 60, 'C', $timestamp);
        $this->validateTran($tm[1]->transaction()->first(), 20, 20, 80);

        $this->postPurchase(100, $timestamp2, 100);
//        $this->dumpTrans();
        $this->assertEquals($transactions->count(), 6);
        $tm = $this->tranRes->referenceTransactionMatching()->get();
        $this->validateTran($tm[0]->transaction()->first(), 70, 70, 250, 'C', $timestamp2);
        $this->validateTran($tm[1]->transaction()->first(), 25, 25, 275);
    }

    public function test_periods()
    {
        $factory = $this->factory;
        // add matching
        $mr3 = $factory->createMatching(100, 50, '2020-01-01', '2022-01-01', 50);

//        $factory->dumpMatchingRules();
        $amr = $mr3->accountMatchingRules()->first();

        // Not report, checking if a match at that time should be considered
        $this->assertFalse($amr->isInPeriod(new Carbon('2019-12-31'), false));
        $this->assertTrue($amr->isInPeriod(new Carbon('2020-01-01'), false));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-01'), false));
        $this->assertFalse($amr->isInPeriod(new Carbon('2022-01-02'), false));

        // ... tran ts, now
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-01'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-02'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(false, new Carbon('2020-01-01'), new Carbon('2020-01-02')));

        // Now, if its a report...
        $this->assertFalse($amr->isInPeriod(new Carbon('2019-12-31'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2020-01-01'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-01'), true));
        $this->assertTrue($amr->isInPeriod(new Carbon('2022-01-02'), true));

        // ... tran ts, now
        $this->assertTrue($amr->isTransactionInTime(true, new Carbon('2020-01-01'), new Carbon('2020-01-01')));
        $this->assertFalse($amr->isTransactionInTime(true, new Carbon('2020-01-02'), new Carbon('2020-01-01')));
        $this->assertTrue($amr->isTransactionInTime(true, new Carbon('2020-01-01'), new Carbon('2020-01-02')));
    }

//    pending tran and other apis / methods
//        see on account ui

    protected function postTransactionError($value, $type, $status, $timestamp=null, $shares=null, $code=200): void
    {
        $this->postTransaction($value, $type, $status, $timestamp, $shares);
        $this->assertApiError($code);
    }

    protected function postTransaction($value, $type, $status, $timestamp=null, $shares=null, $account=null): void
    {
        $transaction = $this->factory->makeTransaction($value, $account, $type, $status, $timestamp, $shares)->toArray();
        $url = '/api/transactions';
        $this->postAPI($url, $transaction);
        if ($this->data != null && array_key_exists('id', $this->data)) {
            $this->tranRes = Transaction::find($this->data['id']);
        }
    }

    private function postPurchase(float $value, $timestamp=null, float $shares, $account=null)
    {
        $this->postTransaction($value, 'PUR', 'P', $timestamp, null, $account);
        $this->assertApiSuccess();
        $this->assertEquals($value, $this->data['value']);
        $this->assertEquals($shares, $this->data['shares']);
        $this->assertEquals('C', $this->data['status']);
    }

    private function validateTran(Transaction $tran, float $value, float $shares, float $balance,
                                  string $status='C', $endDate='9999-12-31')
    {
        $this->assertEquals($value, $tran->value);
        $this->assertEquals($shares, $tran->shares);
        $this->assertEquals($status, $tran->status);
        $bal = $tran->accountBalance()->first();
        $this->assertEquals($balance, $bal->shares);
        $this->assertEquals($endDate, $bal->end_dt->toDateString());
    }


    // Test inPeriod vs consider tran
    // TODO Test show all past matching & considered values
    // TODO Test finds correct matchings while transaction
}
